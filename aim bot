-- init
print("1")

if not game:IsLoaded() then 
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    
    ClassName = "Radius Silent-V1",
    ToggleKey = "RightAlt",
    
    TeamCheck = false,
    VisibleCheck = false, 
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    
    FOVRadius = 130,
    FOVVisible = false,
    DynamicFOV = false,
    DynamicFOVMin = 50,
    DynamicFOVMax = 200,
    DynamicFOVMaxDistance = 400,
    
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100
}

local AimbotSettings = {
    Enabled = false,
    HoldToUse = true,
    HoldKey = "MouseButton2",
    TeamCheck = true,
    VisibleCheck = true,
    TargetPart = "Head",
    MaxDistance = 1200,
    Smoothing = 0.35,
    Prediction = false,
    PredictionMultiplier = 0.12,
    StickyAim = true,
    AutoFire = false,
    AutoFireDelay = 0.18,
    ShowFOV = true,
    FOVRadius = 220,
    DynamicFOV = false,
    DynamicFOVMin = 80,
    DynamicFOVMax = 300,
    DynamicFOVDistance = 450,
    FOVColor = Color3.fromRGB(255, 255, 255),
    ShowTargetInfo = true,
    TargetBonePriority = {"Head", "UpperTorso", "HumanoidRootPart"}
}

local ESPSettings = {
    Enabled = false,
    Boxes = true,
    Tracers = true,
    Names = true,
    Distances = false,
    Health = true,
    UseTeamColor = true,
    TeamCheck = false,
    VisibleCheck = false,
    BoxColor = Color3.fromRGB(54, 57, 241),
    BoxFillColor = Color3.fromRGB(54, 57, 241),
    BoxFillTransparency = 0.35,
    FilledBoxes = false,
    TracerColor = Color3.fromRGB(255, 255, 255),
    TextColor = Color3.fromRGB(255, 255, 255),
    HeadDots = false,
    HeadDotColor = Color3.fromRGB(255, 255, 255),
    HeadDotSize = 6,
    OffscreenArrows = false,
    ArrowColor = Color3.fromRGB(255, 120, 120),
    ArrowRadius = 150,
    ArrowSize = 16,
    ShowTool = false,
    ToolColor = Color3.fromRGB(255, 255, 255),
    ShowVelocity = false,
    VelocityColor = Color3.fromRGB(255, 255, 255),
    Skeleton = false,
    SkeletonColor = Color3.fromRGB(255, 255, 255),
    SkeletonThickness = 1.5,
    GroundCircle = false,
    GroundCircleColor = Color3.fromRGB(255, 255, 255),
    GroundCircleRadius = 6,
    ViewDirection = false,
    ViewDirectionColor = Color3.fromRGB(255, 255, 255),
    CornerBoxes = false,
    CornerColor = Color3.fromRGB(255, 255, 255),
    CornerScale = 0.3,
    MaxDistance = 1000,
    Thickness = 2
}

-- variables
getgenv().SilentAimSettings = Settings
local MainFileName = "UniversalSilentAim"
local SelectedFile, FileToSave = "", ""

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GuiInset = GuiService.GetGuiInset
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume 
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 180
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local aimbot_fov_circle = Drawing.new("Circle")
aimbot_fov_circle.Thickness = 1
aimbot_fov_circle.NumSides = 90
aimbot_fov_circle.Radius = AimbotSettings.FOVRadius
aimbot_fov_circle.Filled = false
aimbot_fov_circle.Visible = false
aimbot_fov_circle.ZIndex = 998
aimbot_fov_circle.Transparency = 1
aimbot_fov_circle.Color = AimbotSettings.FOVColor

local aimbot_target_text = Drawing.new("Text")
aimbot_target_text.Visible = false
aimbot_target_text.Center = true
aimbot_target_text.Outline = true
aimbot_target_text.Size = 14
aimbot_target_text.Color = Color3.fromRGB(255, 255, 255)
aimbot_target_text.ZIndex = 999

local ESPObjects = {}
local function isToggleEnabled(name)
    return (Toggles and Toggles[name] and Toggles[name].Value) or false
end

local GunModConnections = {Character = nil, Backpack = nil}
local function applyGunModifier(object)
    if not object or not object.Name then return end
    local lowerName = object.Name:lower()
    local noRecoilActive = isToggleEnabled("NoRecoil")
    local noSpreadActive = isToggleEnabled("NoSpread")

    if noRecoilActive and (lowerName:find("recoil") or lowerName:find("kick") or (lowerName:find("cam") and lowerName:find("shake"))) then
        if object:IsA("NumberValue") or object:IsA("IntValue") then
            object.Value = 0
        elseif object:IsA("Vector3Value") then
            object.Value = Vector3.new()
        elseif object:IsA("Vector2Value") then
            object.Value = Vector2.new()
        elseif object:IsA("BoolValue") then
            object.Value = false
        end
    end

    if noSpreadActive and (lowerName:find("spread") or lowerName:find("accuracy")) then
        if object:IsA("NumberValue") or object:IsA("IntValue") then
            object.Value = 0
        elseif object:IsA("Vector3Value") then
            object.Value = Vector3.new()
        elseif object:IsA("Vector2Value") then
            object.Value = Vector2.new()
        elseif object:IsA("BoolValue") then
            object.Value = false
        end
    end
end

local function applyGunMods(container)
    if not container then return end
    for _, obj in ipairs(container:GetDescendants()) do
        applyGunModifier(obj)
    end
end

local function bindGunModListener(container, key)
    if GunModConnections[key] then
        GunModConnections[key]:Disconnect()
    end
    if not container then return end
    GunModConnections[key] = container.DescendantAdded:Connect(applyGunModifier)
    applyGunMods(container)
end

local function initGunModListeners()
    if LocalPlayer.Character then
        bindGunModListener(LocalPlayer.Character, "Character")
    end
    LocalPlayer.CharacterAdded:Connect(function(char)
        bindGunModListener(char, "Character")
    end)

    local backpack = LocalPlayer:FindFirstChildOfClass("Backpack") or LocalPlayer:WaitForChild("Backpack")
    bindGunModListener(backpack, "Backpack")
    LocalPlayer.ChildAdded:Connect(function(child)
        if child:IsA("Backpack") then
            bindGunModListener(child, "Backpack")
        end
    end)
end

initGunModListeners()

local SkeletonConnections = {
    R15 = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"}
    },
    R6 = {
        {"Head", "Torso"},
        {"Torso", "Left Arm"},
        {"Left Arm", "Left Leg"},
        {"Torso", "Right Arm"},
        {"Right Arm", "Right Leg"},
        {"Torso", "Left Leg"},
        {"Torso", "Right Leg"}
    }
}

local function getRigConnections(character)
    if character:FindFirstChild("UpperTorso") then
        return SkeletonConnections.R15
    end
    return SkeletonConnections.R6
end

local function getTeamColor(player)
    if not ESPSettings.UseTeamColor then
        return ESPSettings.BoxColor
    end
    
    if player.Team and player.Team.TeamColor then
        return player.Team.TeamColor.Color
    end
    
    if player.TeamColor then
        return player.TeamColor.Color
    end
    
    return ESPSettings.BoxColor
end

local function getEquippedTool(player)
    local character = player.Character
    if character then
        local tool = character:FindFirstChildWhichIsA("Tool")
        if tool then
            return tool.Name
        end
    end
    
    local backpack = player:FindFirstChildOfClass("Backpack")
    if backpack then
        local tool = backpack:FindFirstChildWhichIsA("Tool")
        if tool then
            return tool.Name .. " (Backpack)"
        end
    end
end

local function destroyESP(player)
    local drawings = ESPObjects[player]
    if not drawings then return end
    for _, object in next, drawings do
        if type(object) == "table" then
            for _, sub in next, object do
                if sub and sub.Remove then
                    sub.Visible = false
                    sub:Remove()
                end
            end
        elseif object and object.Remove then
            object.Visible = false
            object:Remove()
        end
    end
    ESPObjects[player] = nil
end

local function createESP(player)
    if player == LocalPlayer or ESPObjects[player] then
        return
    end
    
    local boxOutline = Drawing.new("Square")
    boxOutline.Visible = false
    boxOutline.Color = Color3.new(0, 0, 0)
    boxOutline.Thickness = ESPSettings.Thickness + 2
    boxOutline.Filled = false
    boxOutline.ZIndex = 998
    
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = ESPSettings.BoxColor
    box.Thickness = ESPSettings.Thickness
    box.Filled = false
    box.ZIndex = 999

    local boxFill = Drawing.new("Square")
    boxFill.Visible = false
    boxFill.Color = ESPSettings.BoxFillColor
    boxFill.Filled = true
    boxFill.Transparency = ESPSettings.BoxFillTransparency
    boxFill.ZIndex = 997
    
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Thickness = ESPSettings.Thickness
    tracer.Color = ESPSettings.TracerColor
    tracer.ZIndex = 999
    
    local nameLabel = Drawing.new("Text")
    nameLabel.Visible = false
    nameLabel.Color = ESPSettings.TextColor
    nameLabel.Center = true
    nameLabel.Outline = true
    nameLabel.Size = 14
    nameLabel.ZIndex = 999
    
    local distanceLabel = Drawing.new("Text")
    distanceLabel.Visible = false
    distanceLabel.Color = ESPSettings.TextColor
    distanceLabel.Center = true
    distanceLabel.Outline = true
    distanceLabel.Size = 13
    distanceLabel.ZIndex = 999

    local toolLabel = Drawing.new("Text")
    toolLabel.Visible = false
    toolLabel.Color = ESPSettings.ToolColor
    toolLabel.Center = true
    toolLabel.Outline = true
    toolLabel.Size = 13
    toolLabel.ZIndex = 999

    local velocityLabel = Drawing.new("Text")
    velocityLabel.Visible = false
    velocityLabel.Color = ESPSettings.VelocityColor
    velocityLabel.Center = true
    velocityLabel.Outline = true
    velocityLabel.Size = 13
    velocityLabel.ZIndex = 999
    
    local healthOutline = Drawing.new("Line")
    healthOutline.Visible = false
    healthOutline.Color = Color3.new(0, 0, 0)
    healthOutline.Thickness = ESPSettings.Thickness + 2
    healthOutline.ZIndex = 998
    
    local health = Drawing.new("Line")
    health.Visible = false
    health.Color = Color3.fromRGB(46, 204, 113)
    health.Thickness = ESPSettings.Thickness + 1
    health.ZIndex = 999

    local headDot = Drawing.new("Circle")
    headDot.Visible = false
    headDot.Filled = true
    headDot.Color = ESPSettings.HeadDotColor
    headDot.ZIndex = 999

    local offscreenArrow = Drawing.new("Triangle")
    offscreenArrow.Visible = false
    offscreenArrow.Filled = true
    offscreenArrow.Color = ESPSettings.ArrowColor
    offscreenArrow.Transparency = 0.85
    offscreenArrow.ZIndex = 999
    
    local groundCircle = Drawing.new("Circle")
    groundCircle.Visible = false
    groundCircle.Color = ESPSettings.GroundCircleColor
    groundCircle.Radius = ESPSettings.GroundCircleRadius
    groundCircle.Thickness = ESPSettings.Thickness
    groundCircle.Filled = false
    groundCircle.ZIndex = 998

    local viewDirectionLine = Drawing.new("Line")
    viewDirectionLine.Visible = false
    viewDirectionLine.Color = ESPSettings.ViewDirectionColor
    viewDirectionLine.Thickness = ESPSettings.Thickness
    viewDirectionLine.ZIndex = 999

    local cornerLines = {}
    for i = 1, 8 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = ESPSettings.CornerColor
        line.Thickness = ESPSettings.Thickness
        line.ZIndex = 999
        cornerLines[i] = line
    end

    ESPObjects[player] = {
        Box = box,
        BoxOutline = boxOutline,
        BoxFill = boxFill,
        Tracer = tracer,
        Name = nameLabel,
        Distance = distanceLabel,
        ToolText = toolLabel,
        VelocityText = velocityLabel,
        Health = health,
        HealthOutline = healthOutline,
        HeadDot = headDot,
        OffscreenArrow = offscreenArrow,
        GroundCircle = groundCircle,
        ViewDirectionLine = viewDirectionLine,
        SkeletonLines = {},
        CornerLines = cornerLines
    }
end

local function hideESP(drawings)
    if not drawings then return end
    for _, object in next, drawings do
        if type(object) == "table" then
            for _, sub in next, object do
                if sub then
                    sub.Visible = false
                end
            end
        elseif object then
            object.Visible = false
        end
    end
end

local function hideESPVisuals(drawings)
    if not drawings then return end
    if drawings.BoxOutline then drawings.BoxOutline.Visible = false end
    if drawings.Box then drawings.Box.Visible = false end
    if drawings.BoxFill then drawings.BoxFill.Visible = false end
    if drawings.Tracer then drawings.Tracer.Visible = false end
    if drawings.Name then drawings.Name.Visible = false end
    if drawings.Distance then drawings.Distance.Visible = false end
    if drawings.Health then drawings.Health.Visible = false end
    if drawings.HealthOutline then drawings.HealthOutline.Visible = false end
    if drawings.HeadDot then drawings.HeadDot.Visible = false end
    if drawings.ToolText then drawings.ToolText.Visible = false end
    if drawings.VelocityText then drawings.VelocityText.Visible = false end
    if drawings.GroundCircle then drawings.GroundCircle.Visible = false end
    if drawings.ViewDirectionLine then drawings.ViewDirectionLine.Visible = false end
    if drawings.SkeletonLines then
        for _, line in next, drawings.SkeletonLines do
            if line then
                line.Visible = false
            end
        end
    end
    if drawings.CornerLines then
        for _, line in next, drawings.CornerLines do
            if line then
                line.Visible = false
            end
        end
    end
end

local function updateOffscreenArrow(drawings, rootScreen)
    if not drawings or not drawings.OffscreenArrow then
        return
    end

    if not ESPSettings.OffscreenArrows then
        drawings.OffscreenArrow.Visible = false
        return
    end

    local viewport = Camera.ViewportSize
    local screenCenter = Vector2.new(viewport.X / 2, viewport.Y / 2)
    local screenPos = Vector2.new(rootScreen.X, rootScreen.Y)
    local direction = screenPos - screenCenter

    if rootScreen.Z < 0 then
        direction = -direction
    end
    
    if direction.Magnitude == 0 then
        direction = Vector2.new(0, 1)
    end

    direction = direction.Unit
    local maxRadius = math.max(20, math.min(screenCenter.X, screenCenter.Y) - 20)
    local radius = math.clamp(ESPSettings.ArrowRadius, 20, maxRadius)
    local base = screenCenter + direction * radius
    local size = ESPSettings.ArrowSize

    local leftDir = Vector2.new(-direction.Y, direction.X)
    local rightDir = Vector2.new(direction.Y, -direction.X)

    drawings.OffscreenArrow.PointA = base + direction * size
    drawings.OffscreenArrow.PointB = base + leftDir * (size * 0.6)
    drawings.OffscreenArrow.PointC = base + rightDir * (size * 0.6)
    drawings.OffscreenArrow.Color = ESPSettings.ArrowColor
    drawings.OffscreenArrow.Visible = true
end

local function updateESP()
    for player, drawings in next, ESPObjects do
        if not ESPSettings.Enabled then
            hideESP(drawings)
            continue
        end
        
        local character = player.Character
        if not character then
            hideESP(drawings)
            continue
        end

        if ESPSettings.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            hideESP(drawings)
            continue
        end
        
        if ESPSettings.VisibleCheck and not IsPlayerVisible(player) then
            hideESP(drawings)
            continue
        end
        
        local humanoid = FindFirstChild(character, "Humanoid")
        local humanoidRootPart = FindFirstChild(character, "HumanoidRootPart")
        if not humanoid or not humanoidRootPart or humanoid.Health <= 0 then
            hideESP(drawings)
            continue
        end
        
        local distance = (Camera.CFrame.Position - humanoidRootPart.Position).Magnitude
        if distance > ESPSettings.MaxDistance then
            hideESP(drawings)
            continue
        end
        
        local headPosition = humanoidRootPart.Position + Vector3.new(0, 2.3, 0)
        local legPosition = humanoidRootPart.Position - Vector3.new(0, 2.5, 0)
        local headScreen, headOnScreen = WorldToViewportPoint(Camera, headPosition)
        local legScreen, legOnScreen = WorldToViewportPoint(Camera, legPosition)
        local rootScreen, rootOnScreen = WorldToViewportPoint(Camera, humanoidRootPart.Position)

        if not headOnScreen or not legOnScreen then
            hideESPVisuals(drawings)
            updateOffscreenArrow(drawings, rootScreen)
            if not ESPSettings.OffscreenArrows and drawings.OffscreenArrow then
                drawings.OffscreenArrow.Visible = false
            end
            continue
        else
            if drawings.OffscreenArrow then
                drawings.OffscreenArrow.Visible = false
            end
        end
        
        local boxHeight = math.abs(headScreen.Y - legScreen.Y)
        local boxWidth = boxHeight / 2
        local boxPosition = Vector2.new(headScreen.X - (boxWidth / 2), headScreen.Y)
        
        local color = getTeamColor(player)
        local tracerColor = ESPSettings.UseTeamColor and color or ESPSettings.TracerColor
        
        if drawings.BoxOutline then
            drawings.BoxOutline.Size = Vector2.new(boxWidth, boxHeight)
            drawings.BoxOutline.Position = boxPosition
            drawings.BoxOutline.Visible = ESPSettings.Boxes
            drawings.BoxOutline.Thickness = ESPSettings.Thickness + 2
        end
        
        if drawings.Box then
            drawings.Box.Size = Vector2.new(boxWidth, boxHeight)
            drawings.Box.Position = boxPosition
            drawings.Box.Color = color
            drawings.Box.Visible = ESPSettings.Boxes
            drawings.Box.Thickness = ESPSettings.Thickness
        end

        if drawings.BoxFill then
            drawings.BoxFill.Size = Vector2.new(boxWidth, boxHeight)
            drawings.BoxFill.Position = boxPosition
            drawings.BoxFill.Color = ESPSettings.BoxFillColor
            drawings.BoxFill.Transparency = math.clamp(ESPSettings.BoxFillTransparency, 0, 1)
            drawings.BoxFill.Visible = ESPSettings.FilledBoxes
        end

        if drawings.CornerLines then
            if ESPSettings.CornerBoxes then
                local scale = math.clamp(ESPSettings.CornerScale or 0.3, 0.05, 0.5)
                local cornerLength = math.max(4, math.min(boxWidth, boxHeight) * scale)
                local topLeft = boxPosition
                local topRight = boxPosition + Vector2.new(boxWidth, 0)
                local bottomLeft = boxPosition + Vector2.new(0, boxHeight)
                local bottomRight = boxPosition + Vector2.new(boxWidth, boxHeight)
                local lines = drawings.CornerLines

                lines[1].From = topLeft
                lines[1].To = topLeft + Vector2.new(cornerLength, 0)
                lines[2].From = topLeft
                lines[2].To = topLeft + Vector2.new(0, cornerLength)

                lines[3].From = topRight
                lines[3].To = topRight - Vector2.new(cornerLength, 0)
                lines[4].From = topRight
                lines[4].To = topRight + Vector2.new(0, cornerLength)

                lines[5].From = bottomLeft
                lines[5].To = bottomLeft + Vector2.new(cornerLength, 0)
                lines[6].From = bottomLeft
                lines[6].To = bottomLeft - Vector2.new(0, cornerLength)

                lines[7].From = bottomRight
                lines[7].To = bottomRight - Vector2.new(cornerLength, 0)
                lines[8].From = bottomRight
                lines[8].To = bottomRight - Vector2.new(0, cornerLength)

                for _, line in ipairs(lines) do
                    line.Color = ESPSettings.CornerColor
                    line.Thickness = ESPSettings.Thickness
                    line.Visible = true
                end
            else
                for _, line in next, drawings.CornerLines do
                    if line then
                        line.Visible = false
                    end
                end
            end
        end
        
        if rootOnScreen then
            local screenBottom = Camera.ViewportSize
            drawings.Tracer.From = Vector2.new(screenBottom.X / 2, screenBottom.Y - 40)
            drawings.Tracer.To = Vector2.new(rootScreen.X, rootScreen.Y)
            drawings.Tracer.Color = tracerColor
            drawings.Tracer.Visible = ESPSettings.Tracers
            drawings.Tracer.Thickness = ESPSettings.Thickness
        else
            drawings.Tracer.Visible = false
        end
        
        drawings.Name.Text = player.Name
        drawings.Name.Position = Vector2.new(headScreen.X, headScreen.Y - 18)
        drawings.Name.Color = ESPSettings.TextColor
        drawings.Name.Visible = ESPSettings.Names
        
        drawings.Distance.Text = string.format("%.0f studs", distance)
        drawings.Distance.Position = Vector2.new(headScreen.X, headScreen.Y + boxHeight + 4)
        drawings.Distance.Color = ESPSettings.TextColor
        drawings.Distance.Visible = ESPSettings.Distances

        if drawings.ToolText then
            local toolName = ESPSettings.ShowTool and getEquippedTool(player)
            if toolName then
                drawings.ToolText.Text = tostring(toolName)
                drawings.ToolText.Position = Vector2.new(headScreen.X, headScreen.Y - 34)
                drawings.ToolText.Color = ESPSettings.ToolColor
                drawings.ToolText.Visible = true
            else
                drawings.ToolText.Visible = false
            end
        end

        if drawings.VelocityText then
            if ESPSettings.ShowVelocity then
                local horizontalVelocity = Vector3.new(humanoidRootPart.Velocity.X, 0, humanoidRootPart.Velocity.Z).Magnitude
                drawings.VelocityText.Text = string.format("%.0f sps", horizontalVelocity)
                drawings.VelocityText.Position = Vector2.new(headScreen.X, headScreen.Y + boxHeight + 18)
                drawings.VelocityText.Color = ESPSettings.VelocityColor
                drawings.VelocityText.Visible = true
            else
                drawings.VelocityText.Visible = false
            end
        end
        
        local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local healthHeight = boxHeight * healthPercent
        local healthX = boxPosition.X - 6
        
        drawings.HealthOutline.From = Vector2.new(healthX, boxPosition.Y + boxHeight + 1)
        drawings.HealthOutline.To = Vector2.new(healthX, boxPosition.Y - 1)
        drawings.HealthOutline.Visible = ESPSettings.Health
        drawings.HealthOutline.Thickness = ESPSettings.Thickness + 2
        
        drawings.Health.From = Vector2.new(healthX, boxPosition.Y + boxHeight)
        drawings.Health.To = Vector2.new(healthX, boxPosition.Y + boxHeight - healthHeight)
        drawings.Health.Visible = ESPSettings.Health
        drawings.Health.Thickness = ESPSettings.Thickness + 1

        if drawings.HeadDot then
            drawings.HeadDot.Color = ESPSettings.HeadDotColor
            drawings.HeadDot.Radius = ESPSettings.HeadDotSize
            drawings.HeadDot.Position = Vector2.new(headScreen.X, headScreen.Y)
            drawings.HeadDot.Visible = ESPSettings.HeadDots
        end

        if drawings.GroundCircle and rootOnScreen then
            drawings.GroundCircle.Color = ESPSettings.GroundCircleColor
            drawings.GroundCircle.Radius = ESPSettings.GroundCircleRadius
            drawings.GroundCircle.Position = Vector2.new(rootScreen.X, rootScreen.Y)
            drawings.GroundCircle.Visible = ESPSettings.GroundCircle
        elseif drawings.GroundCircle then
            drawings.GroundCircle.Visible = false
        end

        if drawings.ViewDirectionLine then
            local head = character:FindFirstChild("Head")
            if head and ESPSettings.ViewDirection then
                local lookPosition = head.Position + (head.CFrame.LookVector * 5)
                local lookScreen, lookOnScreen = WorldToViewportPoint(Camera, lookPosition)
                if headOnScreen and lookOnScreen then
                    drawings.ViewDirectionLine.From = Vector2.new(headScreen.X, headScreen.Y)
                    drawings.ViewDirectionLine.To = Vector2.new(lookScreen.X, lookScreen.Y)
                    drawings.ViewDirectionLine.Color = ESPSettings.ViewDirectionColor
                    drawings.ViewDirectionLine.Visible = true
                else
                    drawings.ViewDirectionLine.Visible = false
                end
            else
                drawings.ViewDirectionLine.Visible = false
            end
        end

        if drawings.SkeletonLines then
            if ESPSettings.Skeleton then
                local connections = getRigConnections(character)
                local usedKeys = {}
                for _, pair in ipairs(connections) do
                    local partA = character:FindFirstChild(pair[1])
                    local partB = character:FindFirstChild(pair[2])
                    if partA and partB then
                        local screenA, onScreenA = WorldToViewportPoint(Camera, partA.Position)
                        local screenB, onScreenB = WorldToViewportPoint(Camera, partB.Position)
                        local key = pair[1] .. "_" .. pair[2]
                        local line = drawings.SkeletonLines[key]
                        if not line then
                            line = Drawing.new("Line")
                            line.Visible = false
                            line.Color = ESPSettings.SkeletonColor
                            line.Thickness = ESPSettings.SkeletonThickness
                            line.ZIndex = 999
                            drawings.SkeletonLines[key] = line
                        end
                        if onScreenA and onScreenB then
                            line.From = Vector2.new(screenA.X, screenA.Y)
                            line.To = Vector2.new(screenB.X, screenB.Y)
                            line.Color = ESPSettings.SkeletonColor
                            line.Thickness = ESPSettings.SkeletonThickness
                            line.Visible = true
                        else
                            line.Visible = false
                        end
                        usedKeys[key] = true
                    end
                end
                for key, line in next, drawings.SkeletonLines do
                    if not usedKeys[key] and line then
                        line.Visible = false
                    end
                end
            else
                for _, line in next, drawings.SkeletonLines do
                    if line then
                        line.Visible = false
                    end
                end
            end
        end
    end
end

for _, player in next, GetPlayers(Players) do
    createESP(player)
end

Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    destroyESP(player)
end)


local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean", "boolean"
        }
    },
    FindPartOnRayWithWhitelist = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean"
        }
    },
    FindPartOnRay = {
        ArgCountRequired = 2,
        Args = {
            "Instance", "Ray", "Instance", "boolean", "boolean"
        }
    },
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

function CalculateChance(Percentage)
    -- // Floor the percentage
    Percentage = math.floor(Percentage)

    -- // Get the chance
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100

    -- // Return
    return chance <= Percentage / 100
end


--[[file handling]] do 
    if not isfolder(MainFileName) then 
        makefolder(MainFileName);
    end
    
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then 
        makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId)))
    end
end

local Files = listfiles(string.format("%s/%s", "UniversalSilentAim", tostring(game.PlaceId)))

-- functions
local function GetFiles() -- credits to the linoria lib for this function, listfiles returns the files full path and its annoying
	local out = {}
	for i = 1, #Files do
		local file = Files[i]
		if file:sub(-4) == '.lua' then
			-- i hate this but it has to be done ...

			local pos = file:find('.lua', 1, true)
			local start = pos

			local char = file:sub(pos, pos)
			while char ~= '/' and char ~= '\\' and char ~= '' do
				pos = pos - 1
				char = file:sub(pos, pos)
			end

			if char == '/' or char == '\\' then
				table.insert(out, file:sub(pos + 1, start - 1))
			end
		end
	end
	
	return out
end

local function UpdateFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    writefile(string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName), HttpService:JSONEncode(SilentAimSettings))
end

local function LoadFile(FileName)
    assert(FileName or FileName == "string", "oopsies");
    
    local File = string.format("%s/%s/%s.lua", MainFileName, tostring(game.PlaceId), FileName)
    local ConfigData = HttpService:JSONDecode(readfile(File))
    for Index, Value in next, ConfigData do
        SilentAimSettings[Index] = Value
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getCameraSpreadDirection()
    return Camera.CFrame.LookVector * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    
    local PlayerRoot = FindFirstChild(PlayerCharacter, Options.TargetPart.Value) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    
    if not PlayerRoot then return end 
    
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end

local function getClosestPlayer()
    if not Options.TargetPart.Value then return end
    local Closest
    local DistanceToMouse
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if Toggles.TeamCheck.Value and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end
        
        if Toggles.VisibleCheck.Value and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid and Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or Options.Radius.Value or 2000) then
            Closest = ((Options.TargetPart.Value == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or Character[Options.TargetPart.Value])
            DistanceToMouse = Distance
        end
    end
    return Closest
end

local function getCharacterTargetPart(character, partName)
    if not character then return end
    if partName == "Random" then
        local candidates = {"Head", "UpperTorso", "HumanoidRootPart"}
        local chosen = candidates[math.random(1, #candidates)]
        return character:FindFirstChild(chosen) or character:FindFirstChild("HumanoidRootPart")
    elseif partName == "Priority" then
        for _, bone in ipairs(AimbotSettings.TargetBonePriority) do
            local part = character:FindFirstChild(bone)
            if part then
                return part
            end
        end
        return character:FindFirstChild("HumanoidRootPart")
    else
        return character:FindFirstChild(partName) or character:FindFirstChild("HumanoidRootPart")
    end
end

local function isTargetValid(part)
    if not part then return false end
    local character = part.Parent
    if not character then return false end
    local humanoid = FindFirstChild(character, "Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    return true
end

local function isPlayerVisibleAimbot(player)
    if not AimbotSettings.VisibleCheck then
        return true
    end
    local playerCharacter = player.Character
    local localCharacter = LocalPlayer.Character
    if not playerCharacter or not localCharacter then
        return false
    end
    local targetPart = playerCharacter:FindFirstChild("HumanoidRootPart") or playerCharacter:FindFirstChild("UpperTorso") or playerCharacter:FindFirstChild("Head")
    if not targetPart then
        return false
    end
    local castPoints = {targetPart.Position, localCharacter, playerCharacter}
    local ignoreList = {localCharacter, playerCharacter}
    local obscuringObjects = #GetPartsObscuringTarget(Camera, castPoints, ignoreList)
    return obscuringObjects == 0
end

local function doesInputMatchKey(input, key)
    if not key then return false end
    if key:lower():find("mousebutton") then
        local uitype = Enum.UserInputType[key]
        return uitype and input.UserInputType == uitype
    end
    local success, keycode = pcall(function()
        return Enum.KeyCode[key]
    end)
    if success and keycode then
        return input.KeyCode == keycode
    end
    return false
end

local function getAimbotDisplayRadius(targetPart)
    local radius = AimbotSettings.FOVRadius
    if AimbotSettings.DynamicFOV and targetPart and targetPart.Parent then
        local root = targetPart.Parent:FindFirstChild("HumanoidRootPart")
        if root then
            local distance = (Camera.CFrame.Position - root.Position).Magnitude
            local ratio = 1 - math.clamp(distance / math.max(AimbotSettings.DynamicFOVDistance, 1), 0, 1)
            radius = AimbotSettings.DynamicFOVMin + (AimbotSettings.DynamicFOVMax - AimbotSettings.DynamicFOVMin) * ratio
        end
    end
    return math.clamp(radius, 10, 1000)
end

local function getAimbotTarget(currentTarget)
    local mousePos = getMousePosition()
    local bestTarget
    local shortestDistance = math.huge
    local baseFOV = getAimbotDisplayRadius(currentTarget)

    if AimbotSettings.StickyAim and currentTarget and isTargetValid(currentTarget) then
        local screenPos, onScreen = getPositionOnScreen(currentTarget.Position)
        if onScreen then
            local distance = (mousePos - screenPos).Magnitude
            if distance <= baseFOV then
                bestTarget = currentTarget
                shortestDistance = distance
            end
        end
    end

    for _, player in next, GetPlayers(Players) do
        if player == LocalPlayer then
            continue
        end
        if AimbotSettings.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            continue
        end

        local character = player.Character
        if not character then
            continue
        end

        local humanoid = FindFirstChild(character, "Humanoid")
        local root = FindFirstChild(character, "HumanoidRootPart")
        if not humanoid or humanoid.Health <= 0 or not root then
            continue
        end

        if not isPlayerVisibleAimbot(player) then
            continue
        end

        local distanceFromCamera = (Camera.CFrame.Position - root.Position).Magnitude
        if distanceFromCamera > AimbotSettings.MaxDistance then
            continue
        end

        local targetPart = getCharacterTargetPart(character, AimbotSettings.TargetPart)
        if not targetPart then
            continue
        end

        local screenPosition, onScreen = getPositionOnScreen(targetPart.Position)
        if not onScreen then
            continue
        end

        local distance = (mousePos - screenPosition).Magnitude
        if distance <= baseFOV and distance < shortestDistance then
            shortestDistance = distance
            bestTarget = targetPart
        end
    end

    return bestTarget
end

local function updateAimbotVisuals(isActive, targetPart)
    if AimbotSettings.ShowFOV and isActive then
        aimbot_fov_circle.Visible = true
        aimbot_fov_circle.Color = AimbotSettings.FOVColor
        aimbot_fov_circle.Radius = getAimbotDisplayRadius(targetPart)
        aimbot_fov_circle.Position = getMousePosition()
    else
        aimbot_fov_circle.Visible = false
    end

    if AimbotSettings.ShowTargetInfo and targetPart then
        local character = targetPart.Parent
        local player = character and Players:GetPlayerFromCharacter(character)
        local screenPos, onScreen = getPositionOnScreen(targetPart.Position)
        if player and onScreen then
            aimbot_target_text.Visible = true
            local studs = (Camera.CFrame.Position - targetPart.Position).Magnitude
            aimbot_target_text.Text = string.format("%s | %.0f studs", player.Name, studs)
            aimbot_target_text.Position = Vector2.new(screenPos.X, screenPos.Y - 20)
        else
            aimbot_target_text.Visible = false
        end
    else
        aimbot_target_text.Visible = false
    end
end

local AimbotState = {
    Holding = not AimbotSettings.HoldToUse,
    CurrentTarget = nil,
    LastShot = 0
}

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then
        return
    end
    if AimbotSettings.HoldToUse and doesInputMatchKey(input, AimbotSettings.HoldKey) then
        AimbotState.Holding = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if AimbotSettings.HoldToUse and doesInputMatchKey(input, AimbotSettings.HoldKey) then
        AimbotState.Holding = false
    end
end)
-- ui creating & handling
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()
Library:SetWatermark("Me May Bell")

local Window = Library:CreateWindow({Title = 'Radius-V2', Center = true, AutoShow = true, TabPadding = 8, MenuFadeTime = 0.2})
local GeneralTab = Window:AddTab("Silent")
local MainBOX = GeneralTab:AddLeftTabbox("Main") do
    local Main = MainBOX:AddTab("Main")
    
    Main:AddToggle("aim_Enabled", {Text = "Enabled"}):AddKeyPicker("aim_Enabled_KeyPicker", {Default = "RightAlt", SyncToggleState = true, Mode = "Toggle", Text = "Enabled", NoUI = false});
    Options.aim_Enabled_KeyPicker:OnClick(function()
        SilentAimSettings.Enabled = not SilentAimSettings.Enabled
        
        Toggles.aim_Enabled.Value = SilentAimSettings.Enabled
        Toggles.aim_Enabled:SetValue(SilentAimSettings.Enabled)
    end)
    
    Main:AddToggle("TeamCheck", {Text = "Team Check", Default = SilentAimSettings.TeamCheck}):OnChanged(function()
        SilentAimSettings.TeamCheck = Toggles.TeamCheck.Value
    end)
    Main:AddToggle("VisibleCheck", {Text = "Visible Check", Default = SilentAimSettings.VisibleCheck}):OnChanged(function()
        SilentAimSettings.VisibleCheck = Toggles.VisibleCheck.Value
    end)
    Main:AddDropdown("TargetPart", {AllowNull = true, Text = "Target Part", Default = SilentAimSettings.TargetPart, Values = {"Head", "HumanoidRootPart", "Random"}}):OnChanged(function()
        SilentAimSettings.TargetPart = Options.TargetPart.Value
    end)
    Main:AddDropdown("Method", {AllowNull = true, Text = "Silent Aim Method", Default = SilentAimSettings.SilentAimMethod, Values = {
        "Raycast","FindPartOnRay",
        "FindPartOnRayWithWhitelist",
        "FindPartOnRayWithIgnoreList",
        "Mouse.Hit/Target"
    }}):OnChanged(function() 
        SilentAimSettings.SilentAimMethod = Options.Method.Value 
    end)
    Main:AddSlider('HitChance', {
        Text = 'Hit chance',
        Default = 100,
        Min = 0,
        Max = 100,
        Rounding = 1,
    
        Compact = false,
    })
    Options.HitChance:OnChanged(function()
        SilentAimSettings.HitChance = Options.HitChance.Value
    end)
end

local MiscellaneousBOX = GeneralTab:AddLeftTabbox("Miscellaneous")
local FieldOfViewBOX = GeneralTab:AddLeftTabbox("Field Of View") do
    local Main = FieldOfViewBOX:AddTab("Visuals")
    
    Main:AddToggle("Visible", {Text = "Show FOV Circle"}):AddColorPicker("Color", {Default = Color3.fromRGB(54, 57, 241)}):OnChanged(function()
        fov_circle.Visible = Toggles.Visible.Value
        SilentAimSettings.FOVVisible = Toggles.Visible.Value
    end)
    Main:AddSlider("Radius", {Text = "FOV Circle Radius", Min = 0, Max = 360, Default = 130, Rounding = 0}):OnChanged(function()
        fov_circle.Radius = Options.Radius.Value
        SilentAimSettings.FOVRadius = Options.Radius.Value
    end)
    Main:AddToggle("DynamicFOV", {Text = "Dynamic FOV Scaling", Default = SilentAimSettings.DynamicFOV}):OnChanged(function()
        SilentAimSettings.DynamicFOV = Toggles.DynamicFOV.Value
    end)
    Main:AddSlider("DynamicFOVMin", {Text = "Min FOV Radius", Min = 10, Max = 360, Default = SilentAimSettings.DynamicFOVMin, Rounding = 0}):OnChanged(function()
        SilentAimSettings.DynamicFOVMin = Options.DynamicFOVMin.Value
    end)
    Main:AddSlider("DynamicFOVMax", {Text = "Max FOV Radius", Min = 50, Max = 600, Default = SilentAimSettings.DynamicFOVMax, Rounding = 0}):OnChanged(function()
        SilentAimSettings.DynamicFOVMax = Options.DynamicFOVMax.Value
    end)
    Main:AddSlider("DynamicFOVDistance", {Text = "Dynamic FOV Distance", Min = 50, Max = 1000, Default = SilentAimSettings.DynamicFOVMaxDistance, Rounding = 0}):OnChanged(function()
        SilentAimSettings.DynamicFOVMaxDistance = Options.DynamicFOVDistance.Value
    end)
    local PredictionTab = MiscellaneousBOX:AddTab("Prediction")
    PredictionTab:AddToggle("Prediction", {Text = "Mouse.Hit/Target Prediction"}):OnChanged(function()
        SilentAimSettings.MouseHitPrediction = Toggles.Prediction.Value
    end)
    PredictionTab:AddSlider("Amount", {Text = "Prediction Amount", Min = 0.165, Max = 1, Default = 0.165, Rounding = 3}):OnChanged(function()
        PredictionAmount = Options.Amount.Value
        SilentAimSettings.MouseHitPredictionAmount = Options.Amount.Value
    end)
end

local AimbotTab = Window:AddTab("Aimbot")
local AimbotControlBox = AimbotTab:AddLeftTabbox("Aimbot Controls") do
    local Main = AimbotControlBox:AddTab("Main")
    
    Main:AddToggle("AimbotEnabled", {Text = "Enable Aimbot", Default = AimbotSettings.Enabled}):OnChanged(function()
        AimbotSettings.Enabled = Toggles.AimbotEnabled.Value
    end)
    Main:AddToggle("AimbotHoldToUse", {Text = "Hold To Use", Default = AimbotSettings.HoldToUse}):OnChanged(function()
        AimbotSettings.HoldToUse = Toggles.AimbotHoldToUse.Value
        AimbotState.Holding = not AimbotSettings.HoldToUse
    end)
    Main:AddDropdown("AimbotHoldKey", {Text = "Hold Key", AllowNull = false, Default = AimbotSettings.HoldKey, Values = {"MouseButton1","MouseButton2","Q","E","R","LeftShift","RightAlt"}}):OnChanged(function()
        AimbotSettings.HoldKey = Options.AimbotHoldKey.Value
    end)
    Main:AddToggle("AimbotTeamCheck", {Text = "Team Check", Default = AimbotSettings.TeamCheck}):OnChanged(function()
        AimbotSettings.TeamCheck = Toggles.AimbotTeamCheck.Value
    end)
    Main:AddToggle("AimbotVisibleCheck", {Text = "Visible Check", Default = AimbotSettings.VisibleCheck}):OnChanged(function()
        AimbotSettings.VisibleCheck = Toggles.AimbotVisibleCheck.Value
    end)
    Main:AddDropdown("AimbotTargetPart", {Text = "Target Part", AllowNull = false, Default = AimbotSettings.TargetPart, Values = {"Head","UpperTorso","HumanoidRootPart","Random","Priority"}}):OnChanged(function()
        AimbotSettings.TargetPart = Options.AimbotTargetPart.Value
    end)
    Main:AddSlider("AimbotMaxDistance", {Text = "Max Distance", Min = 100, Max = 2500, Default = AimbotSettings.MaxDistance, Rounding = 0}):OnChanged(function()
        AimbotSettings.MaxDistance = Options.AimbotMaxDistance.Value
    end)
    Main:AddSlider("AimbotSmoothing", {Text = "Smoothing", Min = 0.01, Max = 1, Default = AimbotSettings.Smoothing, Rounding = 2}):OnChanged(function()
        AimbotSettings.Smoothing = Options.AimbotSmoothing.Value
    end)
    Main:AddToggle("AimbotStickyAim", {Text = "Sticky Aim", Default = AimbotSettings.StickyAim}):OnChanged(function()
        AimbotSettings.StickyAim = Toggles.AimbotStickyAim.Value
    end)
    Main:AddToggle("AimbotPrediction", {Text = "Prediction", Default = AimbotSettings.Prediction}):OnChanged(function()
        AimbotSettings.Prediction = Toggles.AimbotPrediction.Value
    end)
    Main:AddSlider("AimbotPredictionMultiplier", {Text = "Prediction Multiplier", Min = 0, Max = 1, Default = AimbotSettings.PredictionMultiplier, Rounding = 3}):OnChanged(function()
        AimbotSettings.PredictionMultiplier = Options.AimbotPredictionMultiplier.Value
    end)
    Main:AddToggle("AimbotAutoFire", {Text = "Auto Fire", Default = AimbotSettings.AutoFire}):OnChanged(function()
        AimbotSettings.AutoFire = Toggles.AimbotAutoFire.Value
    end)
    Main:AddSlider("AimbotAutoFireDelay", {Text = "Auto Fire Delay", Min = 0.05, Max = 1, Default = AimbotSettings.AutoFireDelay, Rounding = 2}):OnChanged(function()
        AimbotSettings.AutoFireDelay = Options.AimbotAutoFireDelay.Value
    end)
    Main:AddToggle("AimbotShowInfo", {Text = "Show Target Info", Default = AimbotSettings.ShowTargetInfo}):OnChanged(function()
        AimbotSettings.ShowTargetInfo = Toggles.AimbotShowInfo.Value
    end)
end

local AimbotVisualBox = AimbotTab:AddRightTabbox("Visuals") do
    local Visuals = AimbotVisualBox:AddTab("FOV")
    Visuals:AddToggle("AimbotShowFOV", {Text = "Show Aimbot FOV", Default = AimbotSettings.ShowFOV}):AddColorPicker("AimbotFOVColor", {Default = AimbotSettings.FOVColor}):OnChanged(function()
        AimbotSettings.ShowFOV = Toggles.AimbotShowFOV.Value
    end)
    Options.AimbotFOVColor:OnChanged(function()
        AimbotSettings.FOVColor = Options.AimbotFOVColor.Value
    end)
    Visuals:AddSlider("AimbotFOVRadius", {Text = "FOV Radius", Min = 25, Max = 700, Default = AimbotSettings.FOVRadius, Rounding = 0}):OnChanged(function()
        AimbotSettings.FOVRadius = Options.AimbotFOVRadius.Value
    end)
    Visuals:AddToggle("AimbotDynamicFOV", {Text = "Dynamic FOV", Default = AimbotSettings.DynamicFOV}):OnChanged(function()
        AimbotSettings.DynamicFOV = Toggles.AimbotDynamicFOV.Value
    end)
    Visuals:AddSlider("AimbotDynamicFOVMin", {Text = "Min Dynamic FOV", Min = 20, Max = 400, Default = AimbotSettings.DynamicFOVMin, Rounding = 0}):OnChanged(function()
        AimbotSettings.DynamicFOVMin = Options.AimbotDynamicFOVMin.Value
    end)
    Visuals:AddSlider("AimbotDynamicFOVMax", {Text = "Max Dynamic FOV", Min = 50, Max = 800, Default = AimbotSettings.DynamicFOVMax, Rounding = 0}):OnChanged(function()
        AimbotSettings.DynamicFOVMax = Options.AimbotDynamicFOVMax.Value
    end)
    Visuals:AddSlider("AimbotDynamicFOVDistance", {Text = "Dynamic FOV Distance", Min = 50, Max = 1500, Default = AimbotSettings.DynamicFOVDistance, Rounding = 0}):OnChanged(function()
        AimbotSettings.DynamicFOVDistance = Options.AimbotDynamicFOVDistance.Value
    end)
end

local GunModsTab = MiscellaneousBOX:AddTab("Gun Mods")
GunModsTab:AddToggle("NoRecoil", {Text = "No Recoil"}):OnChanged(function()
    if Toggles.NoRecoil.Value then
        if LocalPlayer.Character then
            applyGunMods(LocalPlayer.Character)
        end
        local backpack = LocalPlayer:FindFirstChildOfClass("Backpack")
        if backpack then
            applyGunMods(backpack)
        end
    end
end)
GunModsTab:AddToggle("NoSpread", {Text = "No Spread"}):OnChanged(function()
    if Toggles.NoSpread.Value then
        if LocalPlayer.Character then
            applyGunMods(LocalPlayer.Character)
        end
        local backpack = LocalPlayer:FindFirstChildOfClass("Backpack")
        if backpack then
            applyGunMods(backpack)
        end
    end
end)

local ESPTab = Window:AddTab("ESP")
local ESPControlBox = ESPTab:AddLeftTabbox("ESP Controls") do
    local Main = ESPControlBox:AddTab("Settings")
    
    local function hideAllESP()
        for _, drawings in next, ESPObjects do
            hideESP(drawings)
        end
    end
    
    Main:AddToggle("ESPEnabled", {Text = "Enable ESP", Default = ESPSettings.Enabled}):OnChanged(function()
        ESPSettings.Enabled = Toggles.ESPEnabled.Value
        if not ESPSettings.Enabled then
            hideAllESP()
        end
    end)

    Main:AddToggle("ESPTeamCheck", {Text = "Team Check", Default = ESPSettings.TeamCheck}):OnChanged(function()
        ESPSettings.TeamCheck = Toggles.ESPTeamCheck.Value
    end)
    Main:AddToggle("ESPVisibleCheck", {Text = "Visible Check", Default = ESPSettings.VisibleCheck}):OnChanged(function()
        ESPSettings.VisibleCheck = Toggles.ESPVisibleCheck.Value
    end)
    
    Main:AddToggle("ESPBoxes", {Text = "Boxes", Default = ESPSettings.Boxes}):AddColorPicker("ESPBoxColor", {Default = ESPSettings.BoxColor}):OnChanged(function()
        ESPSettings.Boxes = Toggles.ESPBoxes.Value
    end)
    Options.ESPBoxColor:OnChanged(function()
        ESPSettings.BoxColor = Options.ESPBoxColor.Value
    end)
    
    Main:AddToggle("ESPTracers", {Text = "Tracers", Default = ESPSettings.Tracers}):AddColorPicker("ESPTracerColor", {Default = ESPSettings.TracerColor}):OnChanged(function()
        ESPSettings.Tracers = Toggles.ESPTracers.Value
    end)
    Options.ESPTracerColor:OnChanged(function()
        ESPSettings.TracerColor = Options.ESPTracerColor.Value
    end)
    
    Main:AddToggle("ESPNames", {Text = "Names", Default = ESPSettings.Names}):AddColorPicker("ESPTextColor", {Default = ESPSettings.TextColor}):OnChanged(function()
        ESPSettings.Names = Toggles.ESPNames.Value
    end)
    Options.ESPTextColor:OnChanged(function()
        ESPSettings.TextColor = Options.ESPTextColor.Value
    end)

    Main:AddToggle("ESPFilledBoxes", {Text = "Filled Boxes", Default = ESPSettings.FilledBoxes}):AddColorPicker("ESPBoxFillColor", {Default = ESPSettings.BoxFillColor}):OnChanged(function()
        ESPSettings.FilledBoxes = Toggles.ESPFilledBoxes.Value
    end)
    Options.ESPBoxFillColor:OnChanged(function()
        ESPSettings.BoxFillColor = Options.ESPBoxFillColor.Value
    end)
    Main:AddSlider("ESPBoxFillAlpha", {Text = "Fill Transparency", Min = 0.05, Max = 1, Default = ESPSettings.BoxFillTransparency, Rounding = 2}):OnChanged(function()
        ESPSettings.BoxFillTransparency = Options.ESPBoxFillAlpha.Value
    end)
    
    Main:AddToggle("ESPDistances", {Text = "Distances", Default = ESPSettings.Distances}):OnChanged(function()
        ESPSettings.Distances = Toggles.ESPDistances.Value
    end)
    Main:AddToggle("ESPHealth", {Text = "Health Bars", Default = ESPSettings.Health}):OnChanged(function()
        ESPSettings.Health = Toggles.ESPHealth.Value
    end)
    Main:AddToggle("ESPUseTeamColor", {Text = "Use Team Colors", Default = ESPSettings.UseTeamColor}):OnChanged(function()
        ESPSettings.UseTeamColor = Toggles.ESPUseTeamColor.Value
    end)

    Main:AddToggle("ESPHeadDots", {Text = "Head Dots", Default = ESPSettings.HeadDots}):AddColorPicker("ESPHeadDotColor", {Default = ESPSettings.HeadDotColor}):OnChanged(function()
        ESPSettings.HeadDots = Toggles.ESPHeadDots.Value
    end)
    Options.ESPHeadDotColor:OnChanged(function()
        ESPSettings.HeadDotColor = Options.ESPHeadDotColor.Value
    end)
    Main:AddSlider("ESPHeadDotSize", {Text = "Head Dot Size", Min = 2, Max = 14, Default = ESPSettings.HeadDotSize, Rounding = 0}):OnChanged(function()
        ESPSettings.HeadDotSize = Options.ESPHeadDotSize.Value
    end)

    Main:AddToggle("ESPOffscreen", {Text = "Offscreen Arrows", Default = ESPSettings.OffscreenArrows}):AddColorPicker("ESPOffscreenColor", {Default = ESPSettings.ArrowColor}):OnChanged(function()
        ESPSettings.OffscreenArrows = Toggles.ESPOffscreen.Value
    end)
    Options.ESPOffscreenColor:OnChanged(function()
        ESPSettings.ArrowColor = Options.ESPOffscreenColor.Value
    end)
    Main:AddSlider("ESPOffscreenRadius", {Text = "Arrow Radius", Min = 50, Max = 400, Default = ESPSettings.ArrowRadius, Rounding = 0}):OnChanged(function()
        ESPSettings.ArrowRadius = Options.ESPOffscreenRadius.Value
    end)
    Main:AddSlider("ESPOffscreenSize", {Text = "Arrow Size", Min = 6, Max = 30, Default = ESPSettings.ArrowSize, Rounding = 0}):OnChanged(function()
        ESPSettings.ArrowSize = Options.ESPOffscreenSize.Value
    end)

    Main:AddToggle("ESPShowTool", {Text = "Show Tool", Default = ESPSettings.ShowTool}):AddColorPicker("ESPToolColor", {Default = ESPSettings.ToolColor}):OnChanged(function()
        ESPSettings.ShowTool = Toggles.ESPShowTool.Value
    end)
    Options.ESPToolColor:OnChanged(function()
        ESPSettings.ToolColor = Options.ESPToolColor.Value
    end)

    Main:AddToggle("ESPShowVelocity", {Text = "Show Velocity", Default = ESPSettings.ShowVelocity}):AddColorPicker("ESPVelocityColor", {Default = ESPSettings.VelocityColor}):OnChanged(function()
        ESPSettings.ShowVelocity = Toggles.ESPShowVelocity.Value
    end)
    Options.ESPVelocityColor:OnChanged(function()
        ESPSettings.VelocityColor = Options.ESPVelocityColor.Value
    end)

    Main:AddToggle("ESPSkeleton", {Text = "Skeleton", Default = ESPSettings.Skeleton}):AddColorPicker("ESPSkeletonColor", {Default = ESPSettings.SkeletonColor}):OnChanged(function()
        ESPSettings.Skeleton = Toggles.ESPSkeleton.Value
    end)
    Options.ESPSkeletonColor:OnChanged(function()
        ESPSettings.SkeletonColor = Options.ESPSkeletonColor.Value
    end)
    Main:AddSlider("ESPSkeletonThickness", {Text = "Skeleton Thickness", Min = 1, Max = 5, Default = ESPSettings.SkeletonThickness, Rounding = 1}):OnChanged(function()
        ESPSettings.SkeletonThickness = Options.ESPSkeletonThickness.Value
    end)

    Main:AddToggle("ESPGroundCircle", {Text = "Ground Circle", Default = ESPSettings.GroundCircle}):AddColorPicker("ESPGroundCircleColor", {Default = ESPSettings.GroundCircleColor}):OnChanged(function()
        ESPSettings.GroundCircle = Toggles.ESPGroundCircle.Value
    end)
    Options.ESPGroundCircleColor:OnChanged(function()
        ESPSettings.GroundCircleColor = Options.ESPGroundCircleColor.Value
    end)
    Main:AddSlider("ESPGroundCircleRadius", {Text = "Ground Circle Radius", Min = 4, Max = 20, Default = ESPSettings.GroundCircleRadius, Rounding = 0}):OnChanged(function()
        ESPSettings.GroundCircleRadius = Options.ESPGroundCircleRadius.Value
    end)

    Main:AddToggle("ESPViewDirection", {Text = "View Direction", Default = ESPSettings.ViewDirection}):AddColorPicker("ESPViewDirectionColor", {Default = ESPSettings.ViewDirectionColor}):OnChanged(function()
        ESPSettings.ViewDirection = Toggles.ESPViewDirection.Value
    end)
    Options.ESPViewDirectionColor:OnChanged(function()
        ESPSettings.ViewDirectionColor = Options.ESPViewDirectionColor.Value
    end)

    Main:AddToggle("ESPCornerBoxes", {Text = "Corner Boxes", Default = ESPSettings.CornerBoxes}):AddColorPicker("ESPCornerColor", {Default = ESPSettings.CornerColor}):OnChanged(function()
        ESPSettings.CornerBoxes = Toggles.ESPCornerBoxes.Value
    end)
    Options.ESPCornerColor:OnChanged(function()
        ESPSettings.CornerColor = Options.ESPCornerColor.Value
    end)
    Main:AddSlider("ESPCornerScale", {Text = "Corner Size", Min = 0.05, Max = 0.5, Default = ESPSettings.CornerScale, Rounding = 2}):OnChanged(function()
        ESPSettings.CornerScale = Options.ESPCornerScale.Value
    end)
    
    Main:AddSlider("ESPMaxDistance", {Text = "Max ESP Distance", Min = 50, Max = 2000, Default = ESPSettings.MaxDistance, Rounding = 0}):OnChanged(function()
        ESPSettings.MaxDistance = Options.ESPMaxDistance.Value
    end)
    Main:AddSlider("ESPThickness", {Text = "Line Thickness", Min = 1, Max = 5, Default = ESPSettings.Thickness, Rounding = 1}):OnChanged(function()
        ESPSettings.Thickness = Options.ESPThickness.Value
    end)
end

local CreateConfigurationBOX = GeneralTab:AddRightTabbox("Create Configuration") do 
    local Main = CreateConfigurationBOX:AddTab("Create Configuration")
    
    Main:AddInput("CreateConfigTextBox", {Default = "", Numeric = false, Finished = false, Text = "Create Configuration to Create", Tooltip = "Creates a configuration file containing settings you can save and load", Placeholder = "File Name here"}):OnChanged(function()
        if Options.CreateConfigTextBox.Value and string.len(Options.CreateConfigTextBox.Value) ~= "" then 
            FileToSave = Options.CreateConfigTextBox.Value
        end
    end)
    
    Main:AddButton("Create Configuration File", function()
        if FileToSave ~= "" or FileToSave ~= nil then 
            UpdateFile(FileToSave)
        end
    end)
end

local SaveConfigurationBOX = GeneralTab:AddRightTabbox("Save Configuration") do 
    local Main = SaveConfigurationBOX:AddTab("Save Configuration")
    Main:AddDropdown("SaveConfigurationDropdown", {AllowNull = true, Values = GetFiles(), Text = "Choose Configuration to Save"})
    Main:AddButton("Save Configuration", function()
        if Options.SaveConfigurationDropdown.Value then 
            UpdateFile(Options.SaveConfigurationDropdown.Value)
        end
    end)
end

local LoadConfigurationBOX = GeneralTab:AddRightTabbox("Load Configuration") do 
    local Main = LoadConfigurationBOX:AddTab("Load Configuration")
    
    Main:AddDropdown("LoadConfigurationDropdown", {AllowNull = true, Values = GetFiles(), Text = "Choose Configuration to Load"})
    Main:AddButton("Load Configuration", function()
        if table.find(GetFiles(), Options.LoadConfigurationDropdown.Value) then
            LoadFile(Options.LoadConfigurationDropdown.Value)
            
            Toggles.TeamCheck:SetValue(SilentAimSettings.TeamCheck)
            Toggles.VisibleCheck:SetValue(SilentAimSettings.VisibleCheck)
            Options.TargetPart:SetValue(SilentAimSettings.TargetPart)
            Options.Method:SetValue(SilentAimSettings.SilentAimMethod)
            Toggles.Visible:SetValue(SilentAimSettings.FOVVisible)
            Options.Radius:SetValue(SilentAimSettings.FOVRadius)
            Toggles.DynamicFOV:SetValue(SilentAimSettings.DynamicFOV)
            Options.DynamicFOVMin:SetValue(SilentAimSettings.DynamicFOVMin)
            Options.DynamicFOVMax:SetValue(SilentAimSettings.DynamicFOVMax)
            Options.DynamicFOVDistance:SetValue(SilentAimSettings.DynamicFOVMaxDistance)
            Toggles.Prediction:SetValue(SilentAimSettings.MouseHitPrediction)
            Options.Amount:SetValue(SilentAimSettings.MouseHitPredictionAmount)
            Options.HitChance:SetValue(SilentAimSettings.HitChance)
        end
    end)
end

resume(create(function()
    RenderStepped:Connect(function()
        local aimbotActive = AimbotSettings.Enabled and (not AimbotSettings.HoldToUse or AimbotState.Holding)
        if aimbotActive then
            local newTarget = getAimbotTarget(AimbotState.CurrentTarget)
            if newTarget and isTargetValid(newTarget) then
                AimbotState.CurrentTarget = newTarget
                local targetPosition = newTarget.Position
                if AimbotSettings.Prediction then
                    targetPosition = targetPosition + (newTarget.Velocity * AimbotSettings.PredictionMultiplier)
                end
                local desiredCFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
                local smoothing = math.clamp(AimbotSettings.Smoothing, 0.01, 1)
                Camera.CFrame = Camera.CFrame:Lerp(desiredCFrame, smoothing)
                if AimbotSettings.AutoFire and typeof(mouse1press) == "function" and typeof(mouse1release) == "function" and (tick() - AimbotState.LastShot) >= AimbotSettings.AutoFireDelay then
                    mouse1press()
                    task.delay(0.05, mouse1release)
                    AimbotState.LastShot = tick()
                end
            else
                AimbotState.CurrentTarget = nil
            end
        else
            AimbotState.CurrentTarget = nil
        end
        updateAimbotVisuals(aimbotActive, AimbotState.CurrentTarget)

        local currentTarget = Toggles.aim_Enabled.Value and getClosestPlayer() or nil
        local targetCharacter
        local targetRoot
        local rootViewportPoint
        local rootOnScreen = false

        if currentTarget then
            targetCharacter = currentTarget.Parent
            targetRoot = (targetCharacter and targetCharacter.PrimaryPart) or currentTarget
            if targetRoot then
                rootViewportPoint, rootOnScreen = WorldToViewportPoint(Camera, targetRoot.Position)
            end
        end
        
        if Toggles.Visible.Value then 
            fov_circle.Visible = Toggles.Visible.Value
            fov_circle.Color = Options.Color.Value

            local radius = (Options.Radius and Options.Radius.Value) or SilentAimSettings.FOVRadius
            if targetRoot and Toggles.DynamicFOV and Toggles.DynamicFOV.Value and Options.DynamicFOVMin and Options.DynamicFOVMax and Options.DynamicFOVDistance then
                local minRadius = Options.DynamicFOVMin.Value
                local maxRadius = math.max(Options.DynamicFOVMax.Value, minRadius + 1)
                local maxDistance = math.max(Options.DynamicFOVDistance.Value, 1)
                local distance = (Camera.CFrame.Position - targetRoot.Position).Magnitude
                local ratio = 1 - math.clamp(distance / maxDistance, 0, 1)
                radius = minRadius + (maxRadius - minRadius) * ratio
            end
            fov_circle.Radius = math.clamp(radius, 1, 1000)

            if targetRoot and rootOnScreen then
                fov_circle.Position = Vector2.new(rootViewportPoint.X, rootViewportPoint.Y)
            else
            fov_circle.Position = getMousePosition()
            end
        else
            fov_circle.Visible = false
        end

        if ESPSettings.Enabled then
            updateESP()
        else
            for _, drawings in next, ESPObjects do
                hideESP(drawings)
            end
        end
    end)
end))

-- hooks
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local chance = CalculateChance(SilentAimSettings.HitChance)
    local aimEnabled = Toggles.aim_Enabled.Value
    local noSpreadActive = isToggleEnabled("NoSpread")
    local chancePassed = aimEnabled and chance == true
    if self == workspace and not checkcaller() and (chancePassed or noSpreadActive) then
        if Method == "FindPartOnRayWithIgnoreList" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                local A_Ray = Arguments[2]

                local HitPart = chancePassed and getClosestPlayer() or nil
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                elseif noSpreadActive then
                    local Origin = A_Ray.Origin
                    Arguments[2] = Ray.new(Origin, getCameraSpreadDirection())
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "FindPartOnRayWithWhitelist" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                local A_Ray = Arguments[2]

                local HitPart = chancePassed and getClosestPlayer() or nil
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                elseif noSpreadActive then
                    local Origin = A_Ray.Origin
                    Arguments[2] = Ray.new(Origin, getCameraSpreadDirection())
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and Options.Method.Value:lower() == Method:lower() then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                local A_Ray = Arguments[2]

                local HitPart = chancePassed and getClosestPlayer() or nil
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)

                    return oldNamecall(unpack(Arguments))
                elseif noSpreadActive then
                    local Origin = A_Ray.Origin
                    Arguments[2] = Ray.new(Origin, getCameraSpreadDirection())
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "Raycast" and Options.Method.Value == Method then
            if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                local A_Origin = Arguments[2]

                local HitPart = chancePassed and getClosestPlayer() or nil
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    return oldNamecall(unpack(Arguments))
                elseif noSpreadActive then
                    Arguments[3] = getCameraSpreadDirection()
                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex = nil 
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() then
        if Toggles.aim_Enabled.Value and Options.Method.Value == "Mouse.Hit/Target" and getClosestPlayer() then
        local HitPart = getClosestPlayer()
         
        if Index == "Target" or Index == "target" then 
            return HitPart
        elseif Index == "Hit" or Index == "hit" then 
            return ((Toggles.Prediction.Value and (HitPart.CFrame + (HitPart.Velocity * PredictionAmount))) or (not Toggles.Prediction.Value and HitPart.CFrame))
        elseif Index == "X" or Index == "x" then 
            return self.X 
        elseif Index == "Y" or Index == "y" then 
            return self.Y 
        elseif Index == "UnitRay" then 
            return Ray.new(self.Origin, (self.Hit - self.Origin).Unit)
            end
        elseif isToggleEnabled("NoSpread") then
            if Index == "UnitRay" then
                return Ray.new(self.Origin, getCameraSpreadDirection())
            elseif Index == "Hit" or Index == "hit" then
                local origin = self.Origin
                return CFrame.new(origin, origin + getCameraSpreadDirection())
            end
        end
    end

    return oldIndex(self, Index)
end))
